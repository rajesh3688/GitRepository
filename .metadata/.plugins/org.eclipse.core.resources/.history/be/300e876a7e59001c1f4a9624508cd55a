Definition: Selenium WebDriver is a collection of open source APIs which are used to automate the testing of a web application. 
Selenium WebDriver is a web framework that permits you to execute cross-browser tests.
Description: Selenium WebDriver tool is used to automate web application testing to verify that it works as expected.
********************************************************
WebDriver is class or interface?Interface

************************************************************
If you use ChromeDriver driver = new ChromeDriver(); the ChromeDriver instance which will get created through 
that we will be only able to invoke and act on the methods implemented by ChromeDriver and supported by Chrome Browser only. 
To act with other browsers we have to specifically create individual objects as below :

FirefoxDriver driver =  new FirefoxDriver();
InternetExplorerDriver driver = new InternetExplorerDriver();

WebDriver driver = new ChromeDriver();
Through WebDriver driver = new ChromeDriver(); we are creating an instance of the WebDriver interface and casting it to ChromeDriver class. All the browser drivers like:

FirefoxDriver
ChromeDriver
InternetExplorerDriver
PhantomJSDriver
SafariDriver etc

implemented the WebDriver interface

So if we use WebDriver driver, then we can use the already initialized driver (as common object variable) for all browsers we want to automate e.g. Mozilla, Chrome, InternetExplorer, Edge, Opera, Safari as follows:
WebDriver driver = new FirefoxDriver();
// or
WebDriver driver = new ChromeDriver();
// or
WebDriver driver = new InternetExplorerDriver();
// or
WebDriver driver = new EdgeDriver();
// or
WebDriver driver = new OperaDriver();
// or
WebDriver driver = new SafariDriver();
*******************************************************************
Most of the web applications are developed using Ajax and Javascript. When a page is loaded by the browser the elements which we want to interact with may load at different time intervals.

Not only it makes this difficult to identify the element but also if the element is not located it will throw an “ElementNotVisibleException” exception. Using Selenium Waits, we can resolve this problem.

Implicit Wait

The Implicit Wait in Selenium is used to tell the web driver to wait for a certain amount of time before it throws a “No Such Element Exception”. The default setting is 0. Once we set the time, the web driver will wait for the element for that time before throwing an exception.

Implicit Wait syntax:

driver.manage().timeouts().implicitlyWait(TimeOut, TimeUnit.SECONDS);
Implicit wait will accept 2 parameters, the first parameter will accept the time as an integer value and the second parameter will accept the time measurement in terms of SECONDS, MINUTES, MILISECOND, MICROSECONDS, NANOSECONDS, DAYS, HOURS, etc.


Explicit Wait

The Explicit Wait in Selenium is used to tell the Web Driver to wait for certain conditions (Expected Conditions) or maximum time exceeded before throwing “ElementNotVisibleException” exception. It is an intelligent kind of wait, but it can be applied only for specified elements.
It gives better options than implicit wait as it waits for dynamically loaded Ajax elements.
Once we declare explicit wait we have to use “ExpectedConditions” or we can configure how frequently we want to check the condition using Fluent Wait

WebDriverWait wait=new WebDriverWait(driver, 20);
WebElement guru99seleniumlink;
	guru99seleniumlink= wait.until(ExpectedConditions.visibilityOfElementLocated(By.xpath( "/html/body/div[1]/section/div[2]/div/div[1]/div/div[1]/div/div/div/div[2]/div[2]/div/div/div/div/div[1]/div/div/a/i")));
	guru99seleniumlink.click();
	
	The following are the Expected Conditions that can be used in Selenium Explicit Wait

alertIsPresent()
elementSelectionStateToBe()
elementToBeClickable()
elementToBeSelected()
frameToBeAvaliableAndSwitchToIt()
invisibilityOfTheElementLocated()
invisibilityOfElementWithText()
presenceOfAllElementsLocatedBy()
presenceOfElementLocated()
textToBePresentInElement()
textToBePresentInElementLocated()
textToBePresentInElementValue()
titleIs()
titleContains()
visibilityOf()
visibilityOfAllElements()
visibilityOfAllElementsLocatedBy()
visibilityOfElementLocated()

The Fluent Wait in Selenium is used to define maximum time for the web driver to wait for a condition, as well as the frequency with which we want to check the condition before throwing an “ElementNotVisibleException” exception.
It checks for the web element at regular intervals until the object is found or timeout happens.

Let’s consider a scenario where an element is loaded at different intervals of time. 
The element might load within 10 seconds, 20 seconds or even more then that if we declare an explicit wait of 20 seconds. 
It will wait till the specified time before throwing an exception. In such scenarios, the fluent wait is the ideal wait to use as this will try to find the element at different frequency until it finds it or the final timer runs out.

Wait<WebDriver> wait = new FluentWait<WebDriver>(driver)							
			.withTimeout(30, TimeUnit.SECONDS) 			
			.pollingEvery(5, TimeUnit.SECONDS) 			
			.ignoring(NoSuchElementException.class);
			
			Frequency is set to 5 seconds and the maximum time is set to 30 seconds. 
			Thus this means that it will check for the element on the web page at every 5 seconds for the maximum time of 30 seconds. 
			If the element is located within this time frame it will perform the operations else it will throw an” ElementNotVisibleException”
	
	Diffrences between Implicit and Explicit wait
			
			Implicit Wait	Explicit Wait
Implicit Wait time is applied to all the elements in the script
Explicit Wait time is applied only to those elements which are intended by us
In Implicit Wait, we need not specify “ExpectedConditions” on the element to be located
In Explicit Wait, we need to specify “ExpectedConditions” on the element to be located
It is recommended to use when the elements are located with the time frame specified in Selenium implicit wait
It is recommended to use when the elements are taking long time to load and also for verifying the property of the element like(visibilityOfElementLocated, elementToBeClickable,elementToBeSelected)

*********************************************************************
Program to display duplicate elements from selec dropdown

Select s = new Select(driver.findElement(
                By.xpath("//Select[@id='unmappedTech']")));
        List<WebElement> list = s.getOptions();
        Set<String> listNames = new HashSet<String>(list.size());
        for (WebElement element : list) {
           //Set will not allow to add duplicate value
            if(listNames.add(element.getText())==false){
                System.out.println("Duplicate value is: "+element.getText());
            }
        }
        
***************************************************************************

how to run test in testng multiple times

@Test(invocationCount = 100)

public void testCount() {

}



/* Since Data provider for this test method returns 2D array of size 3x1, 
this test method will run 3 times **automatically** with 1 parameter every time. */
@Test(dataProvider="URLprovider")
private void notePrice(String url) {
    driver.get(url);
    System.out.println(driver.getTitle());  
}

// It will return a 2D array of size 3x1
@DataProvider(name="URLprovider")
private Object[][] getURLs() {
  return new Object[][] {
    {"https://www.google.co.in/"},
    {"http://www.gmail.com/"},
    {"http://stackoverflow.com/"}
  };
}

*************************************************************************************
diff options available in TestRunner in Cucumber

package cucumberTest;

import org.junit.runner.RunWith;
import cucumber.api.CucumberOptions;
import cucumber.api.junit.Cucumber;

@RunWith(Cucumber.class)
@CucumberOptions(
		features = "Feature"
		,glue={"stepDefinition"}
		)

public class TestRunner {

}


Following Main Options are available in Cucumber:

https://www.toolsqa.com/gallery/Cucumber/1.Cucumber%20Options.png

Dry Run
dryRun option can either set as true or false. If it is set as true, it means that Cucumber will only check that every Step mentioned in the Feature File has corresponding code written in Step Definition file or not. 
So in case any of the functions are missed in the Step Definition for any Step in Feature File,
 it will give us the message. For practice just add the code 'dryRun = true' in TestRunner class:
 
 package cucumberTest;

import org.junit.runner.RunWith;
import cucumber.api.CucumberOptions;
import cucumber.api.junit.Cucumber;

@RunWith(Cucumber.class)
@CucumberOptions(
		features = "Feature"
		,glue={"stepDefinition"}
		,dryRun = true
		)

public class TestRunner {

}

Now give it a run by Right Click on TestRunner class and Click Run As  > JUnit Test. Cucumber will run the script and the result will be shown in the left-hand side project explorer window in JUnit tab.

https://www.toolsqa.com/gallery/Cucumber/2.CucumberOptions_1.png

Take a look at the time duration at the end of the every Steps, it is (0.000s). 
It means none of the Step is executed but still, Cucumber has made sure that every Step has the corresponding method available in the Step Definition file. Give it a try,
 remove the '@Given("^User is on Home Page$")' statement from the Test_Steps class and run the TestRunner class again.
 
 You would get the following message:
 https://www.toolsqa.com/gallery/Cucumber/3.CucumberOptions_6.png
 
 
 Monochrome
This option can either set as true or false. If it is set as true,
 it means that the console output for the Cucumber test are much more readable. 
 And if it is set as false, then the console output is not as readable as it should be. 
 For practice just add the code 'monochrome = true' in TestRunner class:
 
 package cucumberTest;

import org.junit.runner.RunWith;
import cucumber.api.CucumberOptions;
import cucumber.api.junit.Cucumber;

@RunWith(Cucumber.class)
@CucumberOptions(
		features = "Feature"
		,glue={"stepDefinition"}
		,monochrome = false
		)

public class TestRunner {

}

Now give it a run by Right Click on TestRunner class and Click Run As  > JUnit Test. Cucumber will run the script and Console Output will display like this:


https://www.toolsqa.com/gallery/Cucumber/4.CucumberOptions_2.png

Features Options helps Cucumber to locate the Feature file in the project folder structure. You must have notices that we have been specifying the Feature Option in the TestRunner class since the first chapter. All we need to do is to specify the folder path and Cucumber will automatically find all the '.features' extension files in the folder. It can be specified like:

features = "Feature"

Or if the Feature file is in the deep folder structure

features = "src/test/features"

https://www.toolsqa.com/gallery/Cucumber/6.CucumberOptions_4.png


Glue
It is almost the same think as Features Option but the only difference is that it helps Cucumber to locate the Step Definition file. Whenever Cucumber encounters a Step, it looks for a Step Definition inside all the files present in the folder mentioned in Glue Option. It can be specified like:

glue = "stepDefinition"

Or if the Step Definition file is in the deep folder structure

glue = "src/test/stepDeinition"

https://www.toolsqa.com/gallery/Cucumber/7.CucumberOptions_5.png


Format
Format Option is used to specify different formatting options for the output reports. Various options that can be used as for-matters are:

Pretty: Prints the Gherkin source with additional colors and stack traces for errors. Use below code:

format = {"pretty"}

HTML: This will generate a HTML report at the location mentioned in the for-matter itself. Use below code:

format = {"html:Folder_Name"}

JSON: This report contains all the information from the gherkin source in JSON Format. This report is meant to be post-processed into another visual format by 3rd party tools such as Cucumber Jenkins. Use the below code:

format = {"json:Folder_Name/cucumber.json"}

JUnit: This report generates XML files just like Apache Ant’s JUnit report task. This XML format is understood by most Continuous Integration servers, who will use it to generate visual reports. use the below code:

format = { "junit:Folder_Name/cucumber.xml"}

***********************************************************

what is staleelementexception?

We can resolve StaleElementReferenceException in Selenium webdriver. The term stale means something which is not fresh and decayed. Thus a stale element points to an element which is not present any more.

There may be a case, when an element was in DOM initially but after modifications in Document Object Model (DOM), the element becomes stale and the StaleElementReferenceException is thrown if we make an attempt to access this element.

This exception is caused whenever an element is not present in the DOM, or deleted. We can handle this exception by the following ways −

Refreshing the page and verifying again.

Implement retry method.

import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.chrome.ChromeDriver;
import java.util.concurrent.TimeUnit;
public class StaleElmnt{
   public static void main(String[] args) {
      System.setProperty("webdriver.chrome.driver",
      "C:\\Users\\ghs6kor\\Desktop\\Java\\chromedriver.exe");
      WebDriver driver = new ChromeDriver();
      driver.manage().timeouts().implicitlyWait(5, TimeUnit.SECONDS);
      driver.get("https://www.tutorialspoint.com/about/about_careers.htm");
      // identify element
      WebElement l = driver.findElement(By.id("gsc−i−id1"));
      l.sendKeys("Selenium");
      //refresh page
      driver.navigate().refresh();
      l.sendKeys("Selenium");
      driver.quit();
   }
}

O/P

https://www.tutorialspoint.com/assets/questions/media/47743/dialog.jpg

Code Implementation to fix the StaleElementException.

import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.chrome.ChromeDriver;
import java.util.concurrent.TimeUnit;
import org.openqa.selenium.StaleElementReferenceException;
public class StaleElmntFix{
   public static void main(String[] args) {
      System.setProperty("webdriver.chrome.driver",
      "C:\\Users\\ghs6kor\\Desktop\\Java\\chromedriver.exe");
      WebDriver driver = new ChromeDriver();
      driver.manage().timeouts().implicitlyWait(5, TimeUnit.SECONDS);
      driver.get("https://www.tutorialspoint.com/about/about_careers.htm");
      // identify element
      WebElement l = driver.findElement(By.id("gsc−i−id1"));
      l.sendKeys("Selenium");
      //refresh page
      driver.navigate().refresh();
      //fix exception with try−catch block
      try{
         l.sendKeys("Selenium");
      }
      catch(StaleElementReferenceException e){
         l = driver.findElement(By.id("gsc−i−id1"));
         l.sendKeys("Selenium");
         //obtain value entered
         String s= l.getAttribute("value");
         System.out.println("Value entered is: " +s);
      }
      driver.quit();
   }
}
Output

https://www.tutorialspoint.com/assets/questions/media/47743/enter.jpg

******************************************************************************

how to find missing element using collection?

import java.util.*;
public class Demo{
   public static void main(String[] args){
      List my_list_1 = new ArrayList();
      List my_list_2 = new ArrayList();
      my_list_1.add(new Integer("101"));
      my_list_1.add(new Integer("90"));
      my_list_1.add(new Integer("34"));
      my_list_2.add(new Integer("34"));
      my_list_2.add(new Integer("67"));
      my_list_2.add(new Integer("90"));
      for(int i = 0; i < my_list_1.size(); i++){
         if (my_list_2.contains(my_list_1.get(i)))
         continue;
            else
         System.out.println("The missing element is : "+my_list_1.get(i));
      }
      for(int j=0; j<my_list_2.size();j++){
         if (my_list_1.contains(my_list_2.get(j)))
         continue;
            else
         System.out.println("The new element in the list is : "+my_list_2.get(j));
      }
   }
}
Output
The missing element is : 101
The new element in the list is : 67

***************************************************************************************
Exceptions and errors both are subclasses of Throwable class. The error indicates a problem that mainly occurs due to the lack of system resources and our application should not catch these types of problems.
Some of the examples of errors are system crash error and out of memory error. Errors mostly occur at runtime that's they belong to an unchecked type. 

Exceptions are the problems which can occur at runtime and compile time. 
It mainly occurs in the code written by the developers.  
Exceptions are divided into two categories such as checked exceptions and unchecked exceptions.

Sr.No. Key	     Error	                                 Exception
1      Type     Classified as an unchecked type      Classified as checked and unchecked
 

 
2     Package   It belongs to java.lang.error        It belongs to java.lang.Exception
 
 
 
3   Recoverable/Irrecoverable It is irrecoverable     It is recoverable



4                      It can't be occur at compile time   It can occur at run time compile time both
 	 
 
5  Example       OutOfMemoryError,IOError               NullPointerException , SqlException


Example of Error

public class ErrorExample {
   public static void main(String[] args){
      recursiveMethod(10)
   }
   public static void recursiveMethod(int i){
      while(i!=0){
         i=i+1;
         recursiveMethod(i);
      }
   }
}
Output
Exception in thread "main" java.lang.StackOverflowError


Example of Exception

public class ExceptionExample {
   public static void main(String[] args){
      int x = 100;
      int y = 0;
      int z = x / y;
   }
}
Output
java.lang.ArithmeticException: / by zero

******************************************************************************
What is Exception in Java?
Dictionary Meaning: Exception is an abnormal condition.

In Java, an exception is an event that disrupts the normal flow of the program. It is an object which is thrown at runtime.

What is Exception Handling?
Exception Handling is a mechanism to handle runtime errors such as ClassNotFoundException, IOException, SQLException, RemoteException, etc.

Hierarchy of Java Exception classes
The java.lang.Throwable class is the root class of Java Exception hierarchy inherited by two subclasses: Exception and Error. The hierarchy of Java Exception classes is given below:

https://static.javatpoint.com/core/images/hierarchy-of-exception-handling.png
   at ExceptionExample.main(ExceptionExample.java:7)
   at ErrorExample.ErrorExample(Main.java:42)

 
  