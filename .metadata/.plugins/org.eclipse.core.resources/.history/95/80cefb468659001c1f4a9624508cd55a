Definition: Selenium WebDriver is a collection of open source APIs which are used to automate the testing of a web application. 
Selenium WebDriver is a web framework that permits you to execute cross-browser tests.
Description: Selenium WebDriver tool is used to automate web application testing to verify that it works as expected.
********************************************************
WebDriver is class or interface?Interface

************************************************************
If you use ChromeDriver driver = new ChromeDriver(); the ChromeDriver instance which will get created through 
that we will be only able to invoke and act on the methods implemented by ChromeDriver and supported by Chrome Browser only. 
To act with other browsers we have to specifically create individual objects as below :

FirefoxDriver driver =  new FirefoxDriver();
InternetExplorerDriver driver = new InternetExplorerDriver();

WebDriver driver = new ChromeDriver();
Through WebDriver driver = new ChromeDriver(); we are creating an instance of the WebDriver interface and casting it to ChromeDriver class. All the browser drivers like:

FirefoxDriver
ChromeDriver
InternetExplorerDriver
PhantomJSDriver
SafariDriver etc

implemented the WebDriver interface

So if we use WebDriver driver, then we can use the already initialized driver (as common object variable) for all browsers we want to automate e.g. Mozilla, Chrome, InternetExplorer, Edge, Opera, Safari as follows:
WebDriver driver = new FirefoxDriver();
// or
WebDriver driver = new ChromeDriver();
// or
WebDriver driver = new InternetExplorerDriver();
// or
WebDriver driver = new EdgeDriver();
// or
WebDriver driver = new OperaDriver();
// or
WebDriver driver = new SafariDriver();
*******************************************************************
Most of the web applications are developed using Ajax and Javascript. When a page is loaded by the browser the elements which we want to interact with may load at different time intervals.

Not only it makes this difficult to identify the element but also if the element is not located it will throw an “ElementNotVisibleException” exception. Using Selenium Waits, we can resolve this problem.

Implicit Wait

The Implicit Wait in Selenium is used to tell the web driver to wait for a certain amount of time before it throws a “No Such Element Exception”. The default setting is 0. Once we set the time, the web driver will wait for the element for that time before throwing an exception.

Implicit Wait syntax:

driver.manage().timeouts().implicitlyWait(TimeOut, TimeUnit.SECONDS);
Implicit wait will accept 2 parameters, the first parameter will accept the time as an integer value and the second parameter will accept the time measurement in terms of SECONDS, MINUTES, MILISECOND, MICROSECONDS, NANOSECONDS, DAYS, HOURS, etc.


Explicit Wait

The Explicit Wait in Selenium is used to tell the Web Driver to wait for certain conditions (Expected Conditions) or maximum time exceeded before throwing “ElementNotVisibleException” exception. It is an intelligent kind of wait, but it can be applied only for specified elements.
It gives better options than implicit wait as it waits for dynamically loaded Ajax elements.
Once we declare explicit wait we have to use “ExpectedConditions” or we can configure how frequently we want to check the condition using Fluent Wait

WebDriverWait wait=new WebDriverWait(driver, 20);
WebElement guru99seleniumlink;
	guru99seleniumlink= wait.until(ExpectedConditions.visibilityOfElementLocated(By.xpath( "/html/body/div[1]/section/div[2]/div/div[1]/div/div[1]/div/div/div/div[2]/div[2]/div/div/div/div/div[1]/div/div/a/i")));
	guru99seleniumlink.click();
	
	The following are the Expected Conditions that can be used in Selenium Explicit Wait

alertIsPresent()
elementSelectionStateToBe()
elementToBeClickable()
elementToBeSelected()
frameToBeAvaliableAndSwitchToIt()
invisibilityOfTheElementLocated()
invisibilityOfElementWithText()
presenceOfAllElementsLocatedBy()
presenceOfElementLocated()
textToBePresentInElement()
textToBePresentInElementLocated()
textToBePresentInElementValue()
titleIs()
titleContains()
visibilityOf()
visibilityOfAllElements()
visibilityOfAllElementsLocatedBy()
visibilityOfElementLocated()

The Fluent Wait in Selenium is used to define maximum time for the web driver to wait for a condition, as well as the frequency with which we want to check the condition before throwing an “ElementNotVisibleException” exception.
It checks for the web element at regular intervals until the object is found or timeout happens.

Let’s consider a scenario where an element is loaded at different intervals of time. 
The element might load within 10 seconds, 20 seconds or even more then that if we declare an explicit wait of 20 seconds. 
It will wait till the specified time before throwing an exception. In such scenarios, the fluent wait is the ideal wait to use as this will try to find the element at different frequency until it finds it or the final timer runs out.

Wait<WebDriver> wait = new FluentWait<WebDriver>(driver)							
			.withTimeout(30, TimeUnit.SECONDS) 			
			.pollingEvery(5, TimeUnit.SECONDS) 			
			.ignoring(NoSuchElementException.class);
			
			Frequency is set to 5 seconds and the maximum time is set to 30 seconds. 
			Thus this means that it will check for the element on the web page at every 5 seconds for the maximum time of 30 seconds. 
			If the element is located within this time frame it will perform the operations else it will throw an” ElementNotVisibleException”
	
	Diffrences between Implicit and Explicit wait
			
			Implicit Wait	Explicit Wait
Implicit Wait time is applied to all the elements in the script
Explicit Wait time is applied only to those elements which are intended by us
In Implicit Wait, we need not specify “ExpectedConditions” on the element to be located
In Explicit Wait, we need to specify “ExpectedConditions” on the element to be located
It is recommended to use when the elements are located with the time frame specified in Selenium implicit wait
It is recommended to use when the elements are taking long time to load and also for verifying the property of the element like(visibilityOfElementLocated, elementToBeClickable,elementToBeSelected)

*********************************************************************
Program to display duplicate elements from selec dropdown

Select s = new Select(driver.findElement(
                By.xpath("//Select[@id='unmappedTech']")));
        List<WebElement> list = s.getOptions();
        Set<String> listNames = new HashSet<String>(list.size());
        for (WebElement element : list) {
           //Set will not allow to add duplicate value
            if(listNames.add(element.getText())==false){
                System.out.println("Duplicate value is: "+element.getText());
            }
        }
        
***************************************************************************

how to run test in testng multiple times

@Test(invocationCount = 100)

public void testCount() {

}



/* Since Data provider for this test method returns 2D array of size 3x1, 
this test method will run 3 times **automatically** with 1 parameter every time. */
@Test(dataProvider="URLprovider")
private void notePrice(String url) {
    driver.get(url);
    System.out.println(driver.getTitle());  
}

// It will return a 2D array of size 3x1
@DataProvider(name="URLprovider")
private Object[][] getURLs() {
  return new Object[][] {
    {"https://www.google.co.in/"},
    {"http://www.gmail.com/"},
    {"http://stackoverflow.com/"}
  };
}

*************************************************************************************
diff options available in TestRunner in Cucumber

package cucumberTest;

import org.junit.runner.RunWith;
import cucumber.api.CucumberOptions;
import cucumber.api.junit.Cucumber;

@RunWith(Cucumber.class)
@CucumberOptions(
		features = "Feature"
		,glue={"stepDefinition"}
		)

public class TestRunner {

}


Following Main Options are available in Cucumber:

https://www.toolsqa.com/gallery/Cucumber/1.Cucumber%20Options.png

Dry Run
dryRun option can either set as true or false. If it is set as true, it means that Cucumber will only check that every Step mentioned in the Feature File has corresponding code written in Step Definition file or not. 
So in case any of the functions are missed in the Step Definition for any Step in Feature File,
 it will give us the message. For practice just add the code 'dryRun = true' in TestRunner class:
 
 package cucumberTest;

import org.junit.runner.RunWith;
import cucumber.api.CucumberOptions;
import cucumber.api.junit.Cucumber;

@RunWith(Cucumber.class)
@CucumberOptions(
		features = "Feature"
		,glue={"stepDefinition"}
		,dryRun = true
		)

public class TestRunner {

}

Now give it a run by Right Click on TestRunner class and Click Run As  > JUnit Test. Cucumber will run the script and the result will be shown in the left-hand side project explorer window in JUnit tab.

https://www.toolsqa.com/gallery/Cucumber/2.CucumberOptions_1.png

Take a look at the time duration at the end of the every Steps, it is (0.000s). 
It means none of the Step is executed but still, Cucumber has made sure that every Step has the corresponding method available in the Step Definition file. Give it a try,
 remove the '@Given("^User is on Home Page$")' statement from the Test_Steps class and run the TestRunner class again.
 
 You would get the following message:
 https://www.toolsqa.com/gallery/Cucumber/3.CucumberOptions_6.png
 
 
 Monochrome
This option can either set as true or false. If it is set as true,
 it means that the console output for the Cucumber test are much more readable. 
 And if it is set as false, then the console output is not as readable as it should be. 
 For practice just add the code 'monochrome = true' in TestRunner class:
 
 package cucumberTest;

import org.junit.runner.RunWith;
import cucumber.api.CucumberOptions;
import cucumber.api.junit.Cucumber;

@RunWith(Cucumber.class)
@CucumberOptions(
		features = "Feature"
		,glue={"stepDefinition"}
		,monochrome = false
		)

public class TestRunner {

}

Now give it a run by Right Click on TestRunner class and Click Run As  > JUnit Test. Cucumber will run the script and Console Output will display like this:


https://www.toolsqa.com/gallery/Cucumber/4.CucumberOptions_2.png

Features Options helps Cucumber to locate the Feature file in the project folder structure. You must have notices that we have been specifying the Feature Option in the TestRunner class since the first chapter. All we need to do is to specify the folder path and Cucumber will automatically find all the '.features' extension files in the folder. It can be specified like:

features = "Feature"

Or if the Feature file is in the deep folder structure

features = "src/test/features"

https://www.toolsqa.com/gallery/Cucumber/6.CucumberOptions_4.png


Glue
It is almost the same think as Features Option but the only difference is that it helps Cucumber to locate the Step Definition file. Whenever Cucumber encounters a Step, it looks for a Step Definition inside all the files present in the folder mentioned in Glue Option. It can be specified like:

glue = "stepDefinition"

Or if the Step Definition file is in the deep folder structure

glue = "src/test/stepDeinition"

https://www.toolsqa.com/gallery/Cucumber/7.CucumberOptions_5.png


Format
Format Option is used to specify different formatting options for the output reports. Various options that can be used as for-matters are:

Pretty: Prints the Gherkin source with additional colors and stack traces for errors. Use below code:

format = {"pretty"}

HTML: This will generate a HTML report at the location mentioned in the for-matter itself. Use below code:

format = {"html:Folder_Name"}

JSON: This report contains all the information from the gherkin source in JSON Format. This report is meant to be post-processed into another visual format by 3rd party tools such as Cucumber Jenkins. Use the below code:

format = {"json:Folder_Name/cucumber.json"}

JUnit: This report generates XML files just like Apache Ant’s JUnit report task. This XML format is understood by most Continuous Integration servers, who will use it to generate visual reports. use the below code:

format = { "junit:Folder_Name/cucumber.xml"}

***********************************************************

what is staleelementexception?

We can resolve StaleElementReferenceException in Selenium webdriver. The term stale means something which is not fresh and decayed. Thus a stale element points to an element which is not present any more.

There may be a case, when an element was in DOM initially but after modifications in Document Object Model (DOM), the element becomes stale and the StaleElementReferenceException is thrown if we make an attempt to access this element.

This exception is caused whenever an element is not present in the DOM, or deleted. We can handle this exception by the following ways −

Refreshing the page and verifying again.

Implement retry method.

import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.chrome.ChromeDriver;
import java.util.concurrent.TimeUnit;
public class StaleElmnt{
   public static void main(String[] args) {
      System.setProperty("webdriver.chrome.driver",
      "C:\\Users\\ghs6kor\\Desktop\\Java\\chromedriver.exe");
      WebDriver driver = new ChromeDriver();
      driver.manage().timeouts().implicitlyWait(5, TimeUnit.SECONDS);
      driver.get("https://www.tutorialspoint.com/about/about_careers.htm");
      // identify element
      WebElement l = driver.findElement(By.id("gsc−i−id1"));
      l.sendKeys("Selenium");
      //refresh page
      driver.navigate().refresh();
      l.sendKeys("Selenium");
      driver.quit();
   }
}

O/P

https://www.tutorialspoint.com/assets/questions/media/47743/dialog.jpg

Code Implementation to fix the StaleElementException.

import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.chrome.ChromeDriver;
import java.util.concurrent.TimeUnit;
import org.openqa.selenium.StaleElementReferenceException;
public class StaleElmntFix{
   public static void main(String[] args) {
      System.setProperty("webdriver.chrome.driver",
      "C:\\Users\\ghs6kor\\Desktop\\Java\\chromedriver.exe");
      WebDriver driver = new ChromeDriver();
      driver.manage().timeouts().implicitlyWait(5, TimeUnit.SECONDS);
      driver.get("https://www.tutorialspoint.com/about/about_careers.htm");
      // identify element
      WebElement l = driver.findElement(By.id("gsc−i−id1"));
      l.sendKeys("Selenium");
      //refresh page
      driver.navigate().refresh();
      //fix exception with try−catch block
      try{
         l.sendKeys("Selenium");
      }
      catch(StaleElementReferenceException e){
         l = driver.findElement(By.id("gsc−i−id1"));
         l.sendKeys("Selenium");
         //obtain value entered
         String s= l.getAttribute("value");
         System.out.println("Value entered is: " +s);
      }
      driver.quit();
   }
}
Output

https://www.tutorialspoint.com/assets/questions/media/47743/enter.jpg

******************************************************************************

how to find missing element using collection?

import java.util.*;
public class Demo{
   public static void main(String[] args){
      List my_list_1 = new ArrayList();
      List my_list_2 = new ArrayList();
      my_list_1.add(new Integer("101"));
      my_list_1.add(new Integer("90"));
      my_list_1.add(new Integer("34"));
      my_list_2.add(new Integer("34"));
      my_list_2.add(new Integer("67"));
      my_list_2.add(new Integer("90"));
      for(int i = 0; i < my_list_1.size(); i++){
         if (my_list_2.contains(my_list_1.get(i)))
         continue;
            else
         System.out.println("The missing element is : "+my_list_1.get(i));
      }
      for(int j=0; j<my_list_2.size();j++){
         if (my_list_1.contains(my_list_2.get(j)))
         continue;
            else
         System.out.println("The new element in the list is : "+my_list_2.get(j));
      }
   }
}
Output
The missing element is : 101
The new element in the list is : 67

***************************************************************************************
Exceptions and errors both are subclasses of Throwable class. The error indicates a problem that mainly occurs due to the lack of system resources and our application should not catch these types of problems.
Some of the examples of errors are system crash error and out of memory error. Errors mostly occur at runtime that's they belong to an unchecked type. 

Exceptions are the problems which can occur at runtime and compile time. 
It mainly occurs in the code written by the developers.  
Exceptions are divided into two categories such as checked exceptions and unchecked exceptions.

Sr.No. Key	     Error	                                 Exception
1      Type     Classified as an unchecked type      Classified as checked and unchecked
 

 
2     Package   It belongs to java.lang.error        It belongs to java.lang.Exception
 
 
 
3   Recoverable/Irrecoverable It is irrecoverable     It is recoverable



4                      It can't be occur at compile time   It can occur at run time compile time both
 	 
 
5  Example       OutOfMemoryError,IOError               NullPointerException , SqlException


Example of Error

public class ErrorExample {
   public static void main(String[] args){
      recursiveMethod(10)
   }
   public static void recursiveMethod(int i){
      while(i!=0){
         i=i+1;
         recursiveMethod(i);
      }
   }
}
Output
Exception in thread "main" java.lang.StackOverflowError


Example of Exception

public class ExceptionExample {
   public static void main(String[] args){
      int x = 100;
      int y = 0;
      int z = x / y;
   }
}
Output
java.lang.ArithmeticException: / by zero
at ExceptionExample.main(ExceptionExample.java:7)
   at ErrorExample.ErrorExample(Main.java:42)

******************************************************************************
What is Exception in Java?
Dictionary Meaning: Exception is an abnormal condition.

In Java, an exception is an event that disrupts the normal flow of the program. It is an object which is thrown at runtime.

What is Exception Handling?
Exception Handling is a mechanism to handle runtime errors such as ClassNotFoundException, IOException, SQLException, RemoteException, etc.

Hierarchy of Java Exception classes
The java.lang.Throwable class is the root class of Java Exception hierarchy inherited by two subclasses: Exception and Error. The hierarchy of Java Exception classes is given below:

https://static.javatpoint.com/core/images/hierarchy-of-exception-handling.png

Types of Java Exceptions
There are mainly two types of exceptions: checked and unchecked. An error is considered as the unchecked exception. However, according to Oracle, there are three types of exceptions namely:

Checked Exception
Unchecked Exception
Error

Difference between Checked and Unchecked Exceptions
1) Checked Exception
The classes that directly inherit the Throwable class except RuntimeException and Error are known as checked exceptions. For example, IOException, SQLException, etc. Checked exceptions are checked at compile-time.

2) Unchecked Exception
The classes that inherit the RuntimeException are known as unchecked exceptions. For example, ArithmeticException, NullPointerException, ArrayIndexOutOfBoundsException, etc. Unchecked exceptions are not checked at compile-time, but they are checked at runtime.

3) Error
Error is irrecoverable. Some example of errors are OutOfMemoryError, VirtualMachineError, AssertionError etc.
***************************************************************************************************************
What are the maven plugins used?

maven-clean-plugin
maven-resources-plugin
maven-compiler-plugin
maven-surefire-plugin
maven-jar-plugin
maven-install-plugin
maven-deploy-plugin
maven-site-plugin
maven-project-info-reports-plugin
**********************************************************************************************
what are the diff dependencies used in Maven POM?

cucumber-java
cucumber-junit
cucumber-jvm-deps
cucumber-reporting
gherkin
junit
selenium-java
   
**********************************************************************************************
what are various methods in webdriver?

In Selenium WebDriver, we have an entirely different set of commands for performing different operations. Since we are using Selenium WebDriver with Java, commands are simply methods written in Java language.

Note: A java method is a collection of statements that are grouped together to perform a specific operation.
Before getting into the details of commands provided by Selenium WebDriver, 
we insist you to go through the Java OOPs (Object-Oriented Programming) concepts in java programming language.

https://static.javatpoint.com/tutorial/selenium/images/selenium-webdriver-commands2.png

Method Name
To access any method of any class, we need to create an object of class and then all the public methods will appear for the object.

Parameter
A parameter is an argument which is passed to a method to perform some specific operation.

Return type
Methods can return a value or returning nothing (void). If the void is mentioned after the method, it means, the method is returning no value. If it is returning a value, then it must display the type of the value for e.g. getTitle(): String.


import org.openqa.selenium.By;  
import org.openqa.selenium.WebDriver;  
import org.openqa.selenium.firefox.FirefoxDriver;  
import org.openqa.selenium.remote.DesiredCapabilities;  
import org.openqa.selenium.support.ui.Select;  
  
public class Second {  
  
    public static void main(String[] args) {  
          
          // System Property for Gecko Driver   
    System.setProperty("webdriver.gecko.driver","D:\\GeckoDriver\\geckodriver.exe" );  
          
         // Initialize Gecko Driver using Desired Capabilities Class  
        DesiredCapabilities capabilities = DesiredCapabilities.firefox();  
        capabilities.setCapability("marionette",true);  
        WebDriver driver= new FirefoxDriver(capabilities);  
          
        // Launch Website  
     driver.navigate().to("https://www.testandquiz.com/selenium/testing.html");  
      
        // Fetch the text "This is sample text." and print it on console  
        // Use the class name of the div to locate it and then fetch text using getText() method  
     String sampleText = driver.findElement(By.className("col-md-12")).getText();  
     System.out.println(sampleText);  
          
          // Use the linkText locator method to find the link and perform click using click() method  
     driver.findElement(By.linkText("This is a link")).click();  
       
          // Click on the textbox and send value  
     driver.findElement(By.id("fname")).sendKeys("JavaTpoint");  
       
        // Clear the text written in the textbox  
     driver.findElement(By.id("fname")).clear();  
          
        // Click on the Submit button using click() command  
     driver.findElement(By.id("idOfButton")).click();  
   
        // Locate the radio button by id and check it using click() function  
     driver.findElement(By.id("male")).click();  
          
        // Locate the checkbox by cssSelector and check it using click() function  
     driver.findElement(By.cssSelector("input.Automation")).click();  
              
        // Use Select class for selecting value from dropdown  
    Select dropdown = new Select(driver.findElement(By.id("testingDropdown")));  
    dropdown.selectByVisibleText("Automation Testing");  
       
        // Close the Browser  
             driver.close();  
      
    }  
  
}  
 ***********************************************************************
how does selenium interacts with browser?
 
Selenium Script creates an HTTP Request for each selenium command and sends it to the browser driver.

An HTTP request is then sent to the server using Browser Driver.

The steps are executed on the HTTP server.

The execution status is sent to the HTTP server which is then captured by the automation script.

******************************************************************************

An interface in Java is a blueprint of a class. It has static constants and abstract methods.

The interface in Java is a mechanism to achieve abstraction
. There can be only abstract methods in the Java interface, not method body.
 It is used to achieve abstraction and multiple inheritance in Java
.
In other words, you can say that interfaces can have abstract methods and variables. It cannot have a method body.

Java Interface also represents the IS-A relationship.

It cannot be instantiated just like the abstract class.

Since Java 8, we can have default and static methods in an interface.

Since Java 9, we can have private methods in an interface.


Why use Java interface?
There are mainly three reasons to use interface. They are given below.

It is used to achieve abstraction.
By interface, we can support the functionality of multiple inheritance.
It can be used to achieve loose coupling.

The relationship between classes and interfaces
As shown in the figure given below, a class extends another class, an interface extends another interface, but a class implements an interface.


Multiple inheritance in Java by interface
If a class implements multiple interfaces, or an interface extends multiple interfaces, it is known as multiple inheritance.

*************************************************************************************************
how to handle basic authentication pop up?

We can handle authentication popup with Selenium. To do this, we have to pass the user credentials within the URL. 
We shall have to add the username and password to the URL.


Syntax:
https://username:password@URL
https://admin:admin@the−nternet.herokuapp.com/basic_auth

Here, the admin is the username and password.
URL − www.the-internet.herokuapp.com/basic_auth


Example:

import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.chrome.ChromeDriver;
public class AuthnPopup{
   public static void main(String[] args) {
      System.setProperty("webdriver.chrome.driver",
      "C:\\Users\\ghs6kor\\Desktop\\Java\\chromedriver.exe");
      WebDriver driver = new ChromeDriver();
      String u = "admin";
      // adding username, password with URL
      String str = "https://" + u + ":" + u + "@" +
      "the-internet.herokuapp.com/basic_auth";
      driver.get(str);
      // identify and get text after authentication of popup
      String t = driver.findElement(By.cssSelector("p")).getText();
      System.out.println("Text is: " + t);
      driver.quit();
   }
}
*************************************************************************************************


  